<!DOCTYPE html>
<html>
    <head>
        <title>Timer | NJS.dev</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="icon" type="image/svg+xml" href="/favicon.svg">
        <style>
            /* Ensure padding doesn't increase layout width to avoid horizontal scroll */
            *, *::before, *::after { box-sizing: border-box; }

            html, body {
                height: 100%;
                margin: 0;
            }
            body {
                display: flex;
                align-items: center;
                justify-content: center;
                flex-direction: column;
                min-height: 100vh;
                font-family: Roboto Mono, monospace;
                text-align: center;
                background: #000000;
                color: #ffffff;
                overflow-x: hidden; /* guard against accidental overflow */
            }

            main {
                width: 100%;
                max-width: 100%;
                padding: 2vh 2vw;
            }

            /* Make the time fill more of the viewport while remaining responsive */
            h1#time {
                margin: 0;
                font-weight: 700;
                line-height: 0.9;
                font-size: clamp(48px, 20vmin, 24rem);
                max-height: 80vh;
                overflow: hidden;
                white-space: nowrap;
            }

            h3#date {
                margin: 1.5vh 0 0;
                font-weight: 400;
                font-size: clamp(16px, 4vmin, 3rem);
                opacity: 0.9;
            }

            /* Click-to-toggle audio area */
            main { cursor: pointer; }
        </style>
    </head>
    <body>
        <main>
            <h1 id="time">--:--:--</h1>
            <h3 id="date">----</h3>
            <script>
                function pad(n) { return String(n).padStart(2, '0'); }
                function toLocalISO(dt) {
                    const year = dt.getFullYear();
                    const month = pad(dt.getMonth() + 1);
                    const day = pad(dt.getDate());
                    const hour = pad(dt.getHours());
                    const minute = pad(dt.getMinutes());
                    const second = pad(dt.getSeconds());
                    const tzo = -dt.getTimezoneOffset();
                    const sign = tzo >= 0 ? '+' : '-';
                    const tzHour = pad(Math.floor(Math.abs(tzo) / 60));
                    const tzMin = pad(Math.abs(tzo) % 60);
                    return `${year}-${month}-${day}T${hour}:${minute}:${second}${sign}${tzHour}:${tzMin}`;
                }

                // --- Web Audio pips ---
                const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                const audioCtx = new AudioContextClass();
                let audioEnabled = false;
                let lastBeepSecond = null;
                let pendingAutoStart = false; // true if auto-start requested but resume was blocked by browser

                function beep(frequency = 1000, duration = 100, when = 0, volume = 0.12) {
                    const t = audioCtx.currentTime + when;
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = frequency;
                    gain.gain.setValueAtTime(0, t);
                    gain.gain.linearRampToValueAtTime(volume, t + 0.001);
                    gain.gain.linearRampToValueAtTime(0, t + duration / 1000);
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.start(t);
                    osc.stop(t + duration / 1000 + 0.02);
                }

                function beepSequence(items) {
                    let offset = 0;
                    items.forEach(it => {
                        const d = it.d || 100;
                        const f = it.f || 1000;
                        const v = it.v || 0.12;
                        beep(f, d, offset, v);
                        offset += (it.delay || (d / 1000 + 0.06));
                    });
                }

                function getAudioParam() {
                    const p = new URLSearchParams(location.search).get('audio');
                    if (p === null) return null;
                    if (p === 'true' || p === '1') return true;
                    if (p === 'false' || p === '0') return false;
                    return null;
                }

                function updateAudioParamInUrl(enabled) {
                    try {
                        const url = new URL(location.href);
                        url.searchParams.set('audio', enabled ? 'true' : 'false');
                        history.replaceState(null, '', url.toString());
                    } catch (e) {
                        // ignore if URL manipulation fails
                    }
                }

                function getTzParam() {
                    const raw = new URLSearchParams(location.search).get('tz');
                    if (!raw) return null;
                    // support common casing for UTC
                    if (raw.toLowerCase() === 'utc') return '+00:00';

                    // Normalize cases where '+' was decoded as a space in query strings
                    let t = raw;
                    if (t.charAt(0) === ' ') t = '+' + t.slice(1);

                    // If user supplied offset like '02:00' or '0200' (no sign), assume '+'
                    if (/^\d{2}(:?\d{2})?$/.test(t) || /^\d{4}$/.test(t)) t = '+' + t;

                    return t.trim();
                }

                function parseOffsetMinutes(t) {
                    // accept +HH, +HHMM, +HH:MM, -HH:MM, etc.
                    const m1 = t.match(/^([+-])(\d{2}):(\d{2})$/);
                    if (m1) return (m1[1] === '+' ? 1 : -1) * (parseInt(m1[2], 10) * 60 + parseInt(m1[3], 10));
                    const m2 = t.match(/^([+-])(\d{2})(\d{2})$/);
                    if (m2) return (m2[1] === '+' ? 1 : -1) * (parseInt(m2[2], 10) * 60 + parseInt(m2[3], 10));
                    const m3 = t.match(/^([+-])(\d{2})$/);
                    if (m3) return (m3[1] === '+' ? 1 : -1) * (parseInt(m3[2], 10) * 60);
                    return null;
                }

                function getTimeParts(date, tz) {
                    if (!tz) {
                        return {
                            year: date.getFullYear(),
                            month: pad(date.getMonth() + 1),
                            day: pad(date.getDate()),
                            hour: pad(date.getHours()),
                            minute: pad(date.getMinutes()),
                            second: pad(date.getSeconds())
                        };
                    }

                    // offset-style timezone like +01:00
                    const offsetMin = parseOffsetMinutes(tz);
                    if (offsetMin !== null) {
                        const msUtc = date.getTime();
                        const target = new Date(msUtc + offsetMin * 60000);
                        return {
                            year: target.getUTCFullYear(),
                            month: pad(target.getUTCMonth() + 1),
                            day: pad(target.getUTCDate()),
                            hour: pad(target.getUTCHours()),
                            minute: pad(target.getUTCMinutes()),
                            second: pad(target.getUTCSeconds())
                        };
                    }

                    // Assume IANA timezone and use Intl
                    try {
                        const fmt = new Intl.DateTimeFormat('en-GB', {
                            timeZone: tz,
                            hour12: false,
                            year: 'numeric',
                            month: '2-digit',
                            day: '2-digit',
                            hour: '2-digit',
                            minute: '2-digit',
                            second: '2-digit'
                        });
                        const parts = fmt.formatToParts(date);
                        const map = {};
                        parts.forEach(p => { if (p.type && p.value) map[p.type] = p.value; });
                        return {
                            year: map.year,
                            month: map.month,
                            day: map.day,
                            hour: map.hour,
                            minute: map.minute,
                            second: map.second
                        };
                    } catch (e) {
                        // invalid timezone, fallback to local
                        return {
                            year: date.getFullYear(),
                            month: pad(date.getMonth() + 1),
                            day: pad(date.getDate()),
                            hour: pad(date.getHours()),
                            minute: pad(date.getMinutes()),
                            second: pad(date.getSeconds())
                        };
                    }
                }

                function getTargetParam() {
                    const params = new URLSearchParams(location.search);
                    return params.get('t') || params.get('target') || params.get('until');
                }

                // Parse target ISO parameter (if supplied). If no parameter is present, default to 2 days from now.
                let targetRaw = getTargetParam();
                let targetDate = null;
                if (targetRaw != null) {
                    // user supplied something — try to parse it as ISO datetime
                    const parsed = new Date(targetRaw);
                    if (!isNaN(parsed)) {
                        targetDate = parsed;
                    } else {
                        // Try a simple normalization (space -> T)
                        const alt = new Date(targetRaw.replace(' ', 'T'));
                        if (!isNaN(alt)) targetDate = alt;
                    }
                } else {
                    // No explicit target supplied: default to 2 days in the future (based on user's local time at load)
                    const TWO_DAYS_MS = 2 * 24 * 60 * 60 * 1000;
                    targetDate = new Date(Date.now() + TWO_DAYS_MS);

                    // Auto-populate the URL with the ISO timestamp so it's visible to users on load
                    try {
                        const url = new URL(location.href);
                        // use ISO (UTC) for a canonical, time zone–aware value
                        url.searchParams.set('t', targetDate.toISOString());
                        history.replaceState(null, '', url.toString());
                    } catch (e) {
                        // ignore failures when URL manipulation isn't allowed
                    }
                }

                function setAudioEnabled(enabled, { updateUrl = true } = {}) {
                    audioEnabled = !!enabled;
                    document.body.setAttribute('aria-audio', audioEnabled ? 'on' : 'off');
                    if (updateUrl) updateAudioParamInUrl(audioEnabled);
                    // brief visual flash to acknowledge the change
                    const originalBg = document.body.style.background;
                    document.body.style.transition = 'background 0.08s';
                    document.body.style.background = audioEnabled ? '#0a0a0a' : '#000000';
                    setTimeout(() => { document.body.style.background = originalBg || '#000000'; }, 120);
                }

                // Toggle/resume audio by clicking anywhere on the page
                document.addEventListener('click', async () => {
                    // If audio isn't enabled yet or AudioContext is suspended, try to resume/start
                    if (!audioEnabled || audioCtx.state === 'suspended') {
                        try {
                            await audioCtx.resume();
                        } catch (e) {
                            // resume may fail if browser requires a user gesture; ignore
                        }
                        setAudioEnabled(true, { updateUrl: true });
                        if (pendingAutoStart) {
                            // play a confirmation pip
                            try { beep(950, 80); } catch (e) {}
                            pendingAutoStart = false;
                        }
                    } else {
                        // already running -> toggle off
                        setAudioEnabled(false, { updateUrl: true });
                    }
                });

                // Keyboard accessibility: Space or Enter toggles/resumes audio
                document.addEventListener('keydown', async (e) => {
                    if (e.code === 'Space' || e.code === 'Enter') {
                        e.preventDefault();
                        if (!audioEnabled || audioCtx.state === 'suspended') {
                            try { await audioCtx.resume(); } catch (ex) {}
                            setAudioEnabled(true, { updateUrl: true });
                            if (pendingAutoStart) {
                                try { beep(950,80); } catch (err) {}
                                pendingAutoStart = false;
                            }
                        } else {
                            setAudioEnabled(false, { updateUrl: true });
                        }
                    }
                });

                // Initialize audio state from ?audio= parameter (if provided)
                (function initAudioFromUrl() {
                    const param = getAudioParam();
                    if (param === true) {
                        // mark as enabled; attempt to resume and play a short pip if allowed
                        setAudioEnabled(true, { updateUrl: false });
                        audioCtx.resume().then(() => {
                            try { beep(950, 80); } catch (e) {}
                        }).catch(() => {
                            // resume blocked; mark pending so first user gesture will play confirmation
                            pendingAutoStart = true;
                        });
                    } else if (param === false) {
                        setAudioEnabled(false, { updateUrl: false });
                    }
                })();

                function updateClock() {
                    const now = new Date();

                    if (targetDate) {
                        // Countdown / elapsed mode
                        const diffMs = targetDate.getTime() - now.getTime();
                        const negative = diffMs < 0; // true => target is in the past
                        const absSec = Math.max(0, Math.round(Math.abs(diffMs) / 1000));

                        const days = Math.floor(absSec / 86400);
                        const years = Math.floor(days / 365);
                        const daysRem = days % 365;
                        const hours = Math.floor((absSec % 86400) / 3600);
                        const minutes = Math.floor((absSec % 3600) / 60);
                        const seconds = absSec % 60;

                        let timeStr;
                        if (years > 0) {
                            // show years, remaining days, then H:M:S
                            timeStr = `${years}y ${daysRem}d ${pad(hours)}:${pad(minutes)}:${pad(seconds)}`;
                        } else if (days > 0) {
                            // keep full H:M:S when days are present
                            timeStr = `${days}d ${pad(hours)}:${pad(minutes)}:${pad(seconds)}`;
                        } else if (hours > 0) {
                            // show hours as a labeled prefix and then MM:SS
                            timeStr = `${hours}h ${pad(minutes)}:${pad(seconds)}`;
                        } else if (minutes > 0) {
                            // show minutes as a labeled prefix and seconds
                            timeStr = `${minutes}m ${pad(seconds)}`;
                        } else {
                            // only seconds remain
                            timeStr = `${seconds}s`;
                        }

                        document.getElementById('time').textContent = negative ? `T+ ${timeStr}` : `T- ${timeStr}`;
                        document.getElementById('date').textContent = toLocalISO(targetDate);

                        if (audioEnabled) {
                            // Use the seconds component to avoid duplicate beeps within the same second
                            const s = seconds;
                            if (s === lastBeepSecond) return;
                            lastBeepSecond = s;

                            if (absSec === 0) {
                                // target reached
                                beepSequence([
                                    { f: 800, d: 120 },
                                    { f: 1000, d: 120, delay: 0.18 },
                                    { f: 1200, d: 240, delay: 0.18 }
                                ]);
                            } else if (minutes === 0 && seconds === 0 && hours === 0 && days > 0) {
                                // day tick
                                beepSequence([
                                    { f: 800, d: 120 },
                                    { f: 1000, d: 120, delay: 0.18 },
                                    { f: 1200, d: 240, delay: 0.18 }
                                ]);
                            } else if (minutes === 0 && seconds === 0) {
                                // hour
                                beep(1600, 420);
                            } else if (seconds === 0) {
                                // minute
                                beep(1200, 180);
                            } else {
                                // second
                                beep(950, 80);
                            }
                        }
                    } else {
                        // Original clock mode (no target)
                        const tz = getTzParam();
                        const parts = getTimeParts(now, tz);
                        const timeOnly = `${parts.hour}:${parts.minute}:${parts.second}`;
                        const isoDate = `${parts.year}-${parts.month}-${parts.day}`;
                        document.getElementById('time').textContent = timeOnly;
                        document.getElementById('date').textContent = isoDate;

                        // Audio pips: day > hour > minute > second based on displayed timezone (only one per second)
                        if (audioEnabled) {
                            const s = parseInt(parts.second, 10);
                            const m = parseInt(parts.minute, 10);
                            const h = parseInt(parts.hour, 10);
                            if (s === lastBeepSecond) return; // avoid duplicate when called multiple times
                            lastBeepSecond = s;

                            if (h === 0 && m === 0 && s === 0) {
                                // day: three ascending beeps
                                beepSequence([
                                    { f: 800, d: 120 },
                                    { f: 1000, d: 120, delay: 0.18 },
                                    { f: 1200, d: 240, delay: 0.18 }
                                ]);
                            } else if (m === 0 && s === 0) {
                                // hour: long beep
                                beep(1600, 420);
                            } else if (s === 0) {
                                // minute: medium beep
                                beep(1200, 180);
                            } else {
                                // second: short pip
                                beep(950, 80);
                            }
                        }
                    }

                    // Adjust font sizes to ensure text fits horizontally
                    function fitTextToWidth(el, minFontPx = 12) {
                        if (!el) return;
                        const style = window.getComputedStyle(el);
                        let original = el.dataset.originalFontSize ? parseFloat(el.dataset.originalFontSize) : null;
                        if (!original) {
                            original = parseFloat(style.fontSize);
                            el.dataset.originalFontSize = original;
                        }
                        // Start from the original size to allow increasing when space permits
                        let fs = original;
                        el.style.fontSize = fs + 'px';
                        const available = el.clientWidth;
                        // Reduce font size until it fits or reaches minimum
                        while (el.scrollWidth > available && fs > minFontPx) {
                            fs -= 1;
                            el.style.fontSize = fs + 'px';
                        }
                    }

                    function adjustClockFont() {
                        fitTextToWidth(document.getElementById('time'), 12);
                        fitTextToWidth(document.getElementById('date'), 10);
                    }

                    // ensure size is updated after each tick and on resize
                    adjustClockFont();

                }
                setInterval(updateClock, 1000);
                updateClock(); // initial call
                window.addEventListener('resize', () => {
                    // Debounce briefly to avoid thrashing during resize
                    clearTimeout(window._njsTimerResizeTimeout);
                    window._njsTimerResizeTimeout = setTimeout(() => {
                        // Reset to original before recalculating so text can grow when space increases
                        const t = document.getElementById('time');
                        const d = document.getElementById('date');
                        if (t && t.dataset.originalFontSize) t.style.fontSize = t.dataset.originalFontSize + 'px';
                        if (d && d.dataset.originalFontSize) d.style.fontSize = d.dataset.originalFontSize + 'px';
                        adjustClockFont();
                    }, 80);
                });
            </script>
        </main>
    </body>
</html>
